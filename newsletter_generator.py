# personalized_newsletter.py

import feedparser
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from datetime import datetime
import os
from flask import Flask, jsonify

app = Flask(__name__)

# --- USER PROFILES ---
USERS = {
    "Alex Parker": {
        "interests": ["AI", "cybersecurity", "blockchain", "startups", "programming"],
        "feeds": [
            "https://techcrunch.com/feed/",
            "https://www.wired.com/feed/category/tech/latest/rss",
            "https://arstechnica.com/feed/",
            "https://www.technologyreview.com/feed/"
        ]
    },
    "Priya Sharma": {
        "interests": ["global markets", "startups", "fintech", "cryptocurrency", "economics"],
        "feeds": [
            "https://www.bloomberg.com/feed/podcast/etf-report.xml",
            "https://www.coindesk.com/arc/outboundfeeds/rss/"
        ]
    },
    "Marco Rossi": {
        "interests": ["football", "F1", "NBA", "Olympic sports", "esports"],
        "feeds": [
            "https://www.espn.com/espn/rss/news",
            "http://feeds.bbci.co.uk/sport/rss.xml",
            "https://www.skysports.com/rss/12040",
            "https://theathletic.com/feed/"
        ]
    },
    "Lisa Thompson": {
        "interests": ["movies", "celebrity news", "TV shows", "music", "books"],
        "feeds": [
            "https://variety.com/feed/",
            "https://www.rollingstone.com/music/music-news/feed/",
            "https://www.billboard.com/feed/",
            "https://www.hollywoodreporter.com/t/feed/"
        ]
    },
    "David Martinez": {
        "interests": ["space exploration", "AI", "biotech", "physics", "renewable energy"],
        "feeds": [
            "https://www.nasa.gov/rss/dyn/breaking_news.rss",
            "https://www.sciencedaily.com/rss/all.xml",
            "https://www.nature.com/subjects/technology/rss",
            "https://feeds.arstechnica.com/arstechnica/science"
        ]
    }
}

# --- FETCH ARTICLES ---
def fetch_articles(feed_urls, max_articles=30):
    articles = []
    for url in feed_urls:
        try:
            feed = feedparser.parse(url)
            for entry in feed.entries[:max_articles]:
                summary = entry.get("summary") or entry.get("description", "")
                if not summary:
                    continue
                articles.append({
                    "title": entry.get("title", "No Title"),
                    "link": entry.get("link", "#"),
                    "summary": summary,
                    "published": entry.get("published", "Unknown")
                })
        except Exception as e:
            print(f"‚ö†Ô∏è Error parsing feed {url}: {e}")
    return articles

# --- COMPUTE ARTICLE SCORES ---
def compute_scores(articles, interests):
    content = [article['title'] + " " + article['summary'] for article in articles]
    vectorizer = TfidfVectorizer(stop_words='english')
    try:
        tfidf_matrix = vectorizer.fit_transform(content)
        interest_query = vectorizer.transform([" ".join(interests)])
        scores = cosine_similarity(tfidf_matrix, interest_query).flatten()
    except Exception as e:
        print(f"‚ö†Ô∏è Error computing TF-IDF scores: {e}")
        scores = [0] * len(articles)
    return scores

# --- GENERATE MARKDOWN FILE ---
def generate_markdown(user_name, interests, articles, scores, top_n=10):
    today = datetime.now().strftime("%Y-%m-%d")
    folder_path = os.path.join(os.getcwd(), "newsletters")
    os.makedirs(folder_path, exist_ok=True)

    filename = os.path.join(folder_path, f"{user_name.replace(' ', '_')}_Newsletter_{today}.md")
    top_articles = sorted(zip(articles, scores), key=lambda x: x[1], reverse=True)[:top_n]

    with open(filename, "w", encoding="utf-8") as f:
        f.write(f"# Personalized Newsletter for {user_name}\n")
        f.write(f"Date: {today}\n\n")
        f.write(f"Top Interests: {', '.join(interests)}\n\n")
        f.write("## Highlights:\n\n")

        for i, (article, score) in enumerate(top_articles, 1):
            f.write(f"### {i}. {article['title']}\n")
            f.write(f"*Published:* {article['published']}\n\n")
            f.write(f"{article['summary'][:300].strip()}...\n\n")
            f.write(f"[Read Full Article]({article['link']})\n\n")

        f.write("\n---\nGenerated by an AI-Powered Newsletter System using TF-IDF magic!\n")

    return filename

# --- GENERATE FOR ALL USERS ---
def generate_for_all_users():
    generated = []
    for user_name, user_profile in USERS.items():
        print(f"\nüìù Generating newsletter for {user_name}...")
        articles = fetch_articles(user_profile["feeds"])
        if not articles:
            print(f"‚ö†Ô∏è No articles fetched for {user_name}. Skipping...")
            continue
        scores = compute_scores(articles, user_profile["interests"])
        md_file = generate_markdown(user_name, user_profile["interests"], articles, scores)
        print(f"‚úÖ Newsletter saved: {md_file}")
        generated.append(md_file)
    return generated

# --- FLASK ROUTE TO TRIGGER GENERATION ---
@app.route('/')
def home():
    return "‚úÖ Newsletter Generator is live!"

@app.route('/generate')
def trigger_generation():
    files = generate_for_all_users()
    return jsonify({"status": "success", "generated_files": files})

# --- RUN FLASK APP ---
if __name__ == "__main__":
    app.run(host="0.0.0.0", port=int(os.environ.get("PORT", 5000)))
